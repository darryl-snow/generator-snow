<?php


/** store_in_session()
 * 
 * $key - the name of the information to be stored
 * $value - the information to be stored
 * 
 * This stores something in the session cookie,
 * such as important information that must be
 * available throughout the user's time using
 * the application.
 * 
 * NOTE: we're not using session cookies but rather
 * persistent cookies. This is because NEO LAMP
 * stacks are load balanced and so sessions can't
 * be shared/sync'd between servers. IE users will
 * always get flipped between servers and so will
 * lose the session, resulting in CSRF errors.
 */

function store_in_session($key,$value) {

	setcookie($key,$value,time() + (3600)); // expires after 1 hour

	// if (isset($_SESSION)) {

	// 	$_SESSION[$key]=$value;

	// }

}


/** unset_session()
 * 
 * $key - the name of the information to be cleared
 * 
 * This clears session information that is no longer
 * required.
 * 
 * NOTE: we're not using session cookies but rather
 * persistent cookies. This is because NEO LAMP
 * stacks are load balanced and so sessions can't
 * be shared/sync'd between servers. IE users will
 * always get flipped between servers and so will
 * lose the session, resulting in CSRF errors.
 */

function unset_session($key) {

	$_COOKIE[$key]=' ';
	unset($_COOKIE[$key]);

	// $_SESSION[$key]=' ';
	// unset($_SESSION[$key]);

}


/** get_from_session()
 * 
 * $key - the name of the information to be retrieved
 * 
 * This retrieves information from the session cookie.
 * 
 * NOTE: we're not using session cookies but rather
 * persistent cookies. This is because NEO LAMP
 * stacks are load balanced and so sessions can't
 * be shared/sync'd between servers. IE users will
 * always get flipped between servers and so will
 * lose the session, resulting in CSRF errors.
 */

function get_from_session($key) {

	if (isset($_COOKIE[$key])) {

		return $_COOKIE[$key];

	} else {

		return false; //no session data, no CSRF risk

	}

	// if (isset($_SESSION)) {

	// 	return $_SESSION[$key];

	// } else {

	// 	return false; //no session data, no CSRF risk

	// }

}


/** csrfguard_generate_token()
 * 
 * $unique_form_name - the name of the token to be generated
 * 
 * This generates a unique token that can be used to ensure
 * that form data is only accepted from the application itself
 * and not from other sources.
 */

function csrfguard_generate_token($unique_form_name) {

	// Generate encrypted token as best we can
	if (function_exists("hash_algos") and in_array("sha512",hash_algos())) {

		$token = hash("sha512",mt_rand(0,mt_getrandmax()));

	} else {

		$token = ' ';

		for ($i = 0; $i < 128; ++$i) {

			$r = mt_rand(0,35);

			if ($r<26) {

				$c = chr(ord('a')+$r);

			} else { 

				$c = chr(ord('0')+$r-26);

			} 

			$token .= $c;

		}

	}

	// Store the token in the user's session cookie
	// so that when they submit the form we can confirm
	// it's them.
	store_in_session($unique_form_name,$token);

	return $token;

}


/** csrfguard_validate_token()
 * 
 * $unique_form_name - the name of the token to be validated
 * $token_value - the value to be checked against the incoming token
 * 
 * This checks that the token received from the form is the same
 * as that generated by the application originally, this ensuring
 * that the form data has indeed been sent by the application itself.
 */

function csrfguard_validate_token($unique_form_name,$token_value) {

	// Retrieve the token from the user's session cookie
	$token = get_from_session($unique_form_name);

	if ($token === false) {

		return true;

	} elseif ($token === $token_value) {

		$result = true;

	} else { 

		$result = false;

	}

	// Unset the token from the session cookie, as it's no longer
	// needed.
	unset_session($unique_form_name);

	return $result;

}

?>